# Template metadata for C++ fuzzing project
[template]
name = "CPP"
description = "C++ fuzzing"
version = "1.0.0"

# Template variables with defaults
[variables]
project_name = { required = true, description = "Name of the fuzzing project" }
target_name = { default = "target1", description = "Name of the fuzz target" }



# Supported integration types
[integrations]
#supported = ["script", "make", "cmake"]
supported = ["make", "cmake"]
default = "make"

[[integrations.options]]
name = "make"
description = "Makefile-based build system integration"
files = []

[[integrations.options]]
name = "script"
description = "Self-contained fuzzing setup with build.sh script"
files = []


[[integrations.options]]
name = "cmake"
description = "CMake-based build system integration"
files = []


# File conventions - smart defaults based on directory and extension
[file_conventions]
# Directories always included (core fuzz files)
always_include = ["fuzz"]

# Directories only in full mode (tutorial/example content)
full_mode_only = ["src", "include", "test", "test_data"]

# File extensions that should be templated
template_extensions = [".cpp", ".hpp", ".c", ".h", ".md", ".sh", ".txt"]


# File extensions that should not be templated
no_template_extensions = [".dict", ".bin"]

# Integration-specific files
[[files]]
path = "fuzz/build.sh"
condition = "integration == 'script'"
executable = true

[[files]]
path = "fuzz/Makefile"
condition = "integration == 'make'"

[[files]]
path = "fuzz/CMakeLists.txt"
condition = "integration == 'cmake'"

[[files]]
path = "cmake/Fuzzing.cmake"
condition = "integration == 'cmake'"


# Root-level build files (full mode only)
[[files]]
path = "Makefile"
condition = "integration == 'make' && minimal == false"

[[files]]
path = "CMakeLists.txt"
condition = "integration == 'cmake' && minimal == false"

[[files]]
path = "build.sh"
condition = "integration == 'script' && minimal == false"
executable = true

[[files]]
path = "CMakePresets.json"
condition = "integration == 'cmake' && minimal == false"


[[files]]
path = "fuzz/CMakePresets.json"
condition = "integration == 'cmake' && minimal == true"


# Dictionary files - template filename but not content
[[files]]
path = "fuzz/dictionaries/{{target_name}}.dict"
template = true

# Root-level tutorial files (full mode only)
[[files]]
path = "TUTORIAL.md"
condition = "minimal == false" 

[[files]]
path = "fuzz.sh"
condition = "minimal == false" 
executable = true 

# Directory creation rules
[[directories]]
path = "fuzz/testsuite/{{target_name}}"
create_empty = true  # Create empty directory for corpus files



# Post-generation message
[post_generation_message]
content = """
üéØ {{project_name}} Universal Fuzzing Setup Complete!

{{#if minimal}}
üöÄ Quick Start (Minimal Mode)
Your universal fuzzing harness has been added to the `fuzz/` directory.

1. Build All Compatible Fuzzers
```bash
cd fuzz
make        # Builds all compatible fuzzing targets based on your environment
make test   # Tests the best available fuzzer
```

2. Customize Your Harness
Edit `src/{{target_name}}.cpp` to call your library functions instead of the demo code.

3. Integration with Your Project
The fuzzer will automatically detect and link against your existing library.
For best results, rebuild your library with sanitizers:
```bash
cd ..  # Back to project root
# If using make: make CXXFLAGS+="-fsanitize=address,undefined"
# If using cmake: cmake -S . -B build -DCMAKE_CXX_FLAGS="-fsanitize=address,undefined"
```

{{else}}

üöÄ Quick Start - Environment-Driven Fuzzing
```bash
cd {{project_name}}
make fuzz        # Builds all compatible fuzzers for your environment
make fuzz-test   # Tests fuzzing setup
```

### Individual Fuzzer Targets
- `make fuzz-libfuzzer` - libFuzzer (requires clang++)
- `make fuzz-afl` - AFL++ fuzzing  
- `make fuzz-honggfuzz` - HonggFuzz (requires honggfuzz)
- `make fuzz-standalone` - Standalone binary (works everywhere)

{{/if}}

## Universal Fuzzing Features ‚ú®
- **Environment Detection**: Automatically detects available compilers and fuzzers
- **Standard Library Naming**: Uses `lib{{project_name}}.a` (no fuzzer-specific suffixes)
- **Smart Error Messages**: Helpful guidance when tools are missing
- **Build System Agnostic**: Same functionality across Make, CMake, and build scripts
- **Seamless Integration**: Works with existing projects without name conflicts

## Next Steps
1. üîç Run `make fuzz-info` - See detected environment and capabilities
2. ‚úèÔ∏è Edit `{{#if minimal}}fuzz/{{/if}}src/{{target_name}}.cpp` - Replace demo with your code
3. üöÄ Run `make fuzz` - Build all compatible fuzzers
4. üêõ Start fuzzing:
{{#if minimal}}
   - `cd fuzz && make run-libfuzzer` (if clang++ available)
   - `cd fuzz && make run-standalone` (fallback)
{{else}}
   - `./fuzz/{{target_name}}-libfuzzer testsuite/` (if clang++ available)
   - `./fuzz/{{target_name}}-standalone testsuite/` (fallback)
{{/if}}

## üìö Documentation
{{#if minimal}}
- `fuzz/INTEGRATION.md` - Integration with existing projects
- `fuzz/README.md` - Quick fuzzing reference
{{else}}
- `TUTORIAL.md` - Complete fuzzing tutorial with examples
- `fuzz/INTEGRATION.md` - Integration guide for existing projects  
- `fuzz/README.md` - Quick reference for fuzzing commands
{{/if}}

## Environment-Specific Notes
The generated build system automatically adapts to your environment:

**With clang++**: Full fuzzing with sanitizers (libFuzzer, AFL, HonggFuzz, standalone)
**With g++ only**: Basic AFL and standalone fuzzing (no sanitizers)
**Any compiler**: Standalone mode for Mayhem and manual testing

{{#if (eq integration "cmake")}}
## CMake Integration
- Uses standard CMake target naming conventions
- Automatic compiler and fuzzer detection
- Build with: `cmake --build . --target fuzz`
{{/if}}

{{#if (eq integration "make")}}
## Makefile Integration  
- Universal targets that adapt to your environment
- Standard library naming: `lib{{project_name}}.a`
- Build with: `make fuzz`
{{/if}}

{{#if (eq integration "standalone")}}
## Standalone Script Integration
- Self-contained build scripts with environment detection
- Works without make or cmake dependencies
- Build with: `./build.sh`
{{/if}}

---
**üéØ Ready to fuzz!** The build system will automatically use the best fuzzing setup for your environment.
"""

# Post-generation hooks (optional future feature)
[hooks]
# post_generate = ["chmod +x fuzz/build.sh"]